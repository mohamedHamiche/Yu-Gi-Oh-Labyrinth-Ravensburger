entier modeDeJeu() //demande au joueur de jouer contre joueur ou de jouer contre machine
DEBUT
    entier choix
    Affiche(Quel mode voulez vous ? 1- JvsJ ou  2-JvsMachine)
    Lire(choix)
    si choix = 1
        retourner 1
    sinon
        retourner 2
FIN
---------------------
string lire_pseduo(joueur)
DEBUT 
    afficher(donner votre pseudo)
    lire(pseudo)
    retourne pseudo
FIN
---------------------
distribuerCartes(Joueur player1, Joueur player2)
DEBUT
   entier i=0
   entier j=0
    Tant que i < 24
    Debut
        tableau[i] = remplir aléatoirement avec un entier entre 1 et 24
        j=0
        tant que j < i: // verifie si la valeur entré n'est pas égale à une valeur déja entré auparavant dans le tableau   
                        //de sorte à ce que la pile ne contienne pas les mêmes trésors.
            si(t[i] != t[j])
                 j++   
            finSi
        si(i==j)
            i++
        finSi
    finTantque

    //initialiser la pile des deux joueurs à leur position de départ 
    empiler(player1, 25)
    player1.position_actuelle=(0,0) // (0,0)<-25
    empiler(player2, 26)
    player2.position_actuelle=(6,6)// (6,6)<-26

    //remplir la pile des deux joueurs avec le tableau[24] de valeur aléatoire comprises entre 1 et 24.
    Pour (i=0, i<12, i++)
        empiler(player1, tab[i])
    finPour
    Pour (i=12, i<24, i++)
        empiler(player2, tab[i])
    finPour
FIN
-----------------
joueur QuiCommence (joueur1, joueur2)
DEBUT 
 enrier x = random entre 1 et 2
 si x=1
    retourner joueur1
    sinon 
        retourner joueur2
 finSi
FIN
---------------   
initPlateau(Tuile Plateau[7][7], Tuile *tuile_en_main)
DEBUT
 Pour(i=0, i<6, i++)
    Pour(j=0, j<6, j++)
        Plateau[i][j].posee=0
    finPour
 finPour

 poserTuilesFixes(Plateau[7][7])
 poserTuilesCouloir(Tuile Plateau[7][7])

FIN
----------------
poserTuilesFixes(Tuile Plateau[7][7])
DEBUT
Plateau[0][0].fixe=1
Plateau[0][0].tresor= 25
Plateau[0][0].g=0
Plateau[0][0].d=1
Plateau[0][0].h=0
Plateau[0][0].b=1
Plateau[0][0].posee=1
.
. // 16 fixes au total
.
Plateau[6][6].fixe= 1
Plateau[6][6].tresor= 26
Plateau[6][6].g=1
Plateau[6][6].d=0
Plateau[6][6].h=1
Plateau[6][6].b=0
Plateau[6][6].posee=1
FIN
-------------------
poserTuilesCouloir(Tuile Plateau[7][7],tuile *tuile_en_main)
DEBUT
Tuile tuilesCouloir[34] 
...
// A remplir à la main 
coordonnées pos_aleatoire
entier i=0
Tant que (!plateauRempl ET i<33)
    Debut
    pos_aleatoire.x= valeur aléatoire entre 0 et 6
    pos_aleatoire.y= valeur aléatoire entre 0 et 6

    si (Plateau[pos_aleatoire.x][pos_aleatoire.y].posee==0)
        Plateau[pos_aleatoire.x][pos_aleatoire.y]=tuilesCouloir[i]
        i++
    finSi
tuile_en_main=tuilesCouloir[34]
finTantque
FIN
-----------------------------
alterner(Joueur p1, Joueur p2,Joueur *joueurActuel)
DEBUT
    si joueurActuel == p1
        joueurActuel = p2
    sinon
        joueurActuel = p1
FIN
-----------------------------
insererTuile (Plateau,Tuile *tuile_en_main,coordonnées *choix_precedent)
DEBUT
    coordonnées entré = choixCouloir()
    tant que(!validationCouloir(entré,&choixprécédent))
        entré = choixCouloir()
    FIN TANT QUE
    choixOrientationTuile(Tuile *tuile_en_main)
    choix_precedent = entré

FIN
------------------------------

booléen opposé(coordonnées, &choix_precedent)
DEBUT fonction
 coordonnees tmp
 si(a.x==0 et a.y==1 )
     DEBUT 
        tmp.x=6
      tmp.y=1
      FIN
 
 sinon :
    si(a.x==0 et a.y==3 )
        DEBUT 
            tmp.x=6;
            tmp.y=3;
        FIN
 .
 .
 .
sinon si (a.x==6 et a.y== 1)
     tmp.x=0
     tmp.y=1
 
 sinon
    return 0;
 si
    (tmp.x==b.x et tmp.y == b.y)
        retourner 1;
sinon 
    retourner 0;
-------------------------------------
coordonnées choixCouloir()
DEBUT
    afficher(donnez coordonnées du couloir ou inserer)
    coordonnées a
    lire(a.x)
    lire(a.y)
    retourne a
FIN
-------------------
booléen validationCouloir(coordonnées choix_actuel,coordonnées &choix_precedent)
DEBUT
    si (opposé(choix_actuel,choix_precedent))
        *choix_precedent=choix_actuel
         retourne 1
    finSi
    sinon
        retourne 0
FIN

----------------
choixOrientationTuile(Tuile *tuile_en_main)
DEBUT
    entier choix
    afficher(1.inserer la tuile telle qu'elle est)
    afficher(2.tourner la tuile)
    lire(choix)
    si (choix==2)
        afficher('g' pour gauche 'd' pour droite)
        char direction
        lire(direction)
        entier nbTours
        afficher(combien de tours)
        lire(nbTours)
        tourner(tuile_en_main,nbTours,direction)
    finSi
FIN

-------------------
touner(Tuile *tuile_en_main, entier nombre_de_tours, char direction)
DEBUT
    entier nbTours= nombre_de_tours mod 4 
    si (direction== 'g')
        Pour (entier i=0, i<nbTours, i++)
            tuile_en_main.g=tuile_en_main.h
            tuile_en_main.h=tuile_en_main.d
            tuile_en_main.d=tuile_en_main.b
            tuile_en_main.b=tuile_en_main.g
        finPour
     
     sinon Si (direction== 'd')
                Pour (entier i=0, i<nbTours, i++)
                    tuile_en_main.g=tuile_en_main.b
                    tuile_en_main.h=tuile_en_main.g
                    tuile_en_main.d=tuile_en_main.h
                    tuile_en_main.b=tuile_en_main.d
                finPour
    finSi    
FIN
------------------
decalerCouloir(Tuile Plateau, coordonnees choixCouloir, Tuile *tuile_en_main)
DEBUT
    Tuile tmp 
    entier i = 0
    si choixCouloir.x == 1 OU choixCouloir.x == 7: //
        si choixCouloir.x == 1
            tmp = plateau[choixCouloir.x][choixCouloir.y]
            plateau[choixCouloir.x][choixCouloir.y] = tuile_en_main
            Pour i allant de 2 à 6:
                tmp = plateau[i+1][choixCouloir]
                plateau[i+1][choixCouloir.y] = tmp


        si choixCouloir.x == 7
            tmp = plateau[7][choixCouloir.y]
            plateau[7][choixCouloir.y] = tuile_en_main
            Pour i allant de 7 à 2:
                plateau[i][choixCouloir.y] = tmp
                tmp = plateau[i-1][choixCouloir.y]

    sinon si choixCouloir.y == 1 OU choixCouloir.y == 7:
        si choixCouloir.y == 1
            tmp = plateau[choixCouloir.x][1]
            plateau[choixCouloir.x][1] = tuile_en_main
        Pour i allant de 2 à 6:
                plateau[i][1] = tmp
                tmp = plateau[i+1][1]
        si choixCouloir.y == 7
            tmp = plateau[choixCouloir.x][7]
            plateau[choixCouloir.x][7] = tuile_en_main
            tmp = tuile_en_main
            Pour i allant de 6 à 2:
                plateau[choixCouloir.x][i] = tmp
                tmp = plateau[choixCouloir.x][i-1]
            
    tuile_en_main = &tmp
FIN

----------------------
booléen validationCoup(coordonnées a,int compt)
DEBUT
    Si(tresorAtteit)
        retourne 1
        Sinon si (compt== 100) // supposons que le plus long chemin est de taille 100
            rerourne 0 
                 Sinon Si (tab[a.x][a.y].d==1) 
                        a.y++
                        Sinon Si(tab[a.x][a.y].h==1) 
                            a.x--
                            Sinon Si(tab[a.x][a.y].g==1) 
                                a.y--
                                Sinon Si(tab[a.x][a.y].b==1) 
                                    a.x++
    fin Si    

  retourne validationCoup(a,compt++)
FIN
-------------------------
booléen validationCoup(Tuile *case,coordonnees a,int compt)
DEBUT
    si(tresorAtteit)
        retourne 1
    si(compt == 300) // Le plus long chemin possible pour être certain que la fonction parcours tous les chemins possible à partir de la coordonnees
        retourne 0

    si (tab[a.x][a.y].d == 1 ET tab[a.x][a.y] != case) // Si le trésor n'est pas atteint et que la case précédente n'est pas égale à la case actuel
        a.y++                                          // On déplace la coordonnees vers la "droite" ...
        res =validationCoup(tab[a.x][a.y--],a,compt++) // Appel récursif 

    si (tab[a.x][a.y].h == 1 ET tab[a.x][a.y] != case) //...
        a.x--                                          //... 
        res= validationCoup(tab[a.x++][a.y],a,compt++) //...

    si (tab[a.x][a.y].g == 1 ET tab[a.x][a.y] != case)
        a.y--
        res= validationCoup(tab[a.x][a.y++],a,compt++)
        
    si (tab[a.x][a.y].b == 1 ET tab[a.x][a.y] != case)
        a.x++
        res= validationCoup(tab[a.x--][a.y],a,compt++)
        
    retourne res
FIN
-----------------------   


        
