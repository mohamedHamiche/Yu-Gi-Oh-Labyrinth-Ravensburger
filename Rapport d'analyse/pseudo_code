entier modeDeJeu() //demande au joueur de jouer contre joueur ou de jouer contre machine
DEBUT
    entier choix
    Affiche(Quel mode voulez vous ? 1- JvsJ ou  2-JvsMachine)
    Lire(choix)
    si choix = 1
        retourner 1
    sinon
        retourner 2
FIN
---------------------
string lire_pseudo()
DEBUT 
    afficher(donner votre pseudo)
    lire(pseudo)
    retourne pseudo
FIN
----------------------
initPosition(Joueur *P1, Joueur *P2)
DEBUT
    P1.x = 0
    P1.y = 0
    P2.x = 6
    P2.y = 6
FIN
----------------------
distribuerCartes(Joueur P1, Joueur P2)
DEBUT
   entier i=0
   entier j=0
    Tant que i < 24
    Debut
        tableau[i] = remplir aléatoirement avec un entier entre 1 et 24
        j=0
        Tant que j < i: // verifie si la valeur entré n'est pas égale à une valeur déja entré auparavant dans le tableau   
                        //de sorte à ce que la pile ne contienne pas les mêmes trésors.
            si(t[i] != t[j])
                 j++   
            finSi
        si(i==j)
            i++
        finSi
    fin tant que

    //initialiser la pile des deux joueurs à leur position de départ 
    empiler(P1, 25)
    empiler(P2, 26)

    //remplir la pile des deux joueurs avec le tableau[24] de valeur aléatoire comprises entre 1 et 24.
    Pour (i=0, i<12, i++)
        empiler(P1, tab[i])
    finPour
    Pour (i=12, i<24, i++)
        empiler(P2, tab[i])
    finPour
FIN
-----------------
Joueur quiCommence (Joueur *P1, Joueur *P2)
DEBUT 
    entier x = random entre 1 et 2
    si x=1
        retourner P1
    sinon 
        retourner P2
    finSi
FIN
---------------   
initPlateau(Tuile Plateau[7][7], Tuile *tuile_en_main)
DEBUT
    Pour(i=0, i<6, i++)
        Pour(j=0, j<6, j++)
            Plateau[i][j].posee=0
        finPour
    finPour

    poserTuilesFixes(Plateau)
    poserTuilesCouloir(Plateau, tuile_en_main)

FIN
----------------
poserTuilesFixes(Tuile Plateau[7][7])
DEBUT
    Plateau[0][0].fixe=1
    Plateau[0][0].tresor= 25
    Plateau[0][0].g=0
    Plateau[0][0].d=1
    Plateau[0][0].h=0
    Plateau[0][0].b=1
    Plateau[0][0].posee=1
    .
    . // 16 fixes au total
    .
    Plateau[6][6].fixe= 1
    Plateau[6][6].tresor= 26
    Plateau[6][6].g=1
    Plateau[6][6].d=0
    Plateau[6][6].h=1
    Plateau[6][6].b=0
    Plateau[6][6].posee=1
FIN
----------------------------
poserTuilesCouloir(Tuile Plateau[7][7],tuile *tuile_en_main)
DEBUT
    Tuile tuilesCouloir[34] 
    ...
    // A remplir à la main 
    coordonnées pos_aleatoire
    entier i=0
    Tant que (!plateauRempl ET i<33)
    pos_aleatoire.x= valeur aléatoire entre 0 et 6
    pos_aleatoire.y= valeur aléatoire entre 0 et 6

    si (Plateau[pos_aleatoire.x][pos_aleatoire.y].posee==0)
        Plateau[pos_aleatoire.x][pos_aleatoire.y]=tuilesCouloir[i]
        i++
    finSi
    tuile_en_main=tuilesCouloir[34]
    Fin Tant que
FIN
-----------------------------
alterner(Joueur *p1, Joueur *p2,Joueur *joueurActuel)
DEBUT
    si joueurActuel == p1
        joueurActuel = p2
    sinon
        joueurActuel = p1
FIN
-----------------------------
insererTuile (Tuile plateau[7][7],Tuile *tuile_en_main,coordonnées *choix_precedent)
DEBUT
    coordonnées entré = choixCouloir()
    tant que(!validationCouloir(entré,&choixprécédent))
        entré = choixCouloir()
    Fin tant que
    choixOrientationTuile(Tuile *tuile_en_main)
    (*choix_precedent) = entré
    decalerCouloir(plateau, entré, tuile_en_main)
FIN
------------------------------

booléen opposé(coordonnées a, coordonnées choix_precedent)// on veut savoir si a est choix sont opposés 
DEBUT fonction
    coordonnees tmp // pour trouver l'opposé de a 
    si(a.x==0 et a.y==1)
        tmp.x=6
        tmp.y=1
    Fin si
 
 sinon:
    si(a.x==0 et a.y==3)
            tmp.x=6;
            tmp.y=3;
    Fin si
 .
 .
 .
    sinon si (a.x==6 et a.y== 1)
        tmp.x=0
        tmp.y=1
 
    sinon
        return 0;
    si // l'opposé de a (tmp) est le choix_actuel alors OUI 
        (tmp.x==choix_precedent.x et tmp.y == choix_precedent.y)
        retourner 1;
    fin si

    sinon 
        retourner 0;
FIN
-------------------------------------
coordonnées choixCouloir()
DEBUT
    afficher(donnez coordonnées du couloir ou inserer)
    coordonnées a
    lire(a.x)
    lire(a.y)
    retourne a
FIN
-------------------
booléen validationCouloir(coordonnées choix_actuel,coordonnées *choix_precedent)
DEBUT
    si (opposé(choix_actuel,(*choix_precedent))
        (*choix_precedent) = choix_actuel
         retourne 1
    fin Si
    sinon
        retourne 0
FIN

----------------
choixOrientationTuile(Tuile *tuile_en_main)
DEBUT
    entier choix
    afficher(1.inserer la tuile telle qu'elle est)
    afficher(2.tourner la tuile)
    lire(choix)
    si (choix==2)
        afficher('g' pour gauche 'd' pour droite)
        char direction
        lire(direction)
        entier nbTours
        afficher(combien de tours)
        lire(nbTours)
        tourner(tuile_en_main,nbTours,direction)
    fin Si
FIN

-------------------
touner(Tuile *tuile_en_main, entier nombre_de_tours, char direction)
    // tuile_en_main: adresse de la tuile en main
    // nombre_de_tours: entier entre 0 et 3
    // direction: g pour gauche, d pour droite
DEBUT
    entier nbTours= nombre_de_tours mod 4 
    si (direction == 'g')
        Pour (entier i=0, i<nbTours, i++)
            tuile_en_main.g=tuile_en_main.h
            tuile_en_main.h=tuile_en_main.d
            tuile_en_main.d=tuile_en_main.b
            tuile_en_main.b=tuile_en_main.g
        fin Pour
     
    sinon si (direction== 'd')
                Pour (entier i=0, i<nbTours, i++)
                    tuile_en_main.g=tuile_en_main.b
                    tuile_en_main.h=tuile_en_main.g
                    tuile_en_main.d=tuile_en_main.h
                    tuile_en_main.b=tuile_en_main.d
                fin Pour
    fin Si    
FIN
------------------
decalerCouloir(Tuile Plateau, coordonnees choixCouloir, Tuile *tuile_en_main)
    // Principe de la fonction: 4 orientations de décalage d'un couloir, par exemple si on insert coté 'Ouest' il y aura un décalage du couloir de 
    //...gauche vers la droite ainsi on modifie la ligne du plateau correspondant.
    // Autre exemple: Si on insert coté Nord il y aura un décalage du haut vers le bas donc la fonction va modifier la colonne en partant du haut ...
DEBUT
    Tuile tmp 
    entier i = 0
    si choixCouloir.x == 1 OU choixCouloir.x == 7: //
        si choixCouloir.x == 1
            tmp = plateau[choixCouloir.x][choixCouloir.y]
            plateau[choixCouloir.x][choixCouloir.y] = tuile_en_main
            Pour i allant de 2 à 6:
                tmp = plateau[i+1][choixCouloir]
                plateau[i+1][choixCouloir.y] = tmp
        fin si
    fin si

        si choixCouloir.x == 7
            tmp = plateau[7][choixCouloir.y]
            plateau[7][choixCouloir.y] = tuile_en_main

            Pour i allant de 7 à 2:
                plateau[i][choixCouloir.y] = tmp
                tmp = plateau[i-1][choixCouloir.y]
            fin pour
        fin si

        sinon si choixCouloir.y == 1 OU choixCouloir.y == 7:
            si choixCouloir.y == 1
                tmp = plateau[choixCouloir.x][1]
                plateau[choixCouloir.x][1] = tuile_en_main
            Pour i allant de 2 à 6:
                plateau[i][1] = tmp
                tmp = plateau[i+1][1]
            fin pour

        si choixCouloir.y == 7
            tmp = plateau[choixCouloir.x][7]
            plateau[choixCouloir.x][7] = tuile_en_main
            tmp = tuile_en_main
            Pour i allant de 6 à 2:
                plateau[choixCouloir.x][i] = tmp
                tmp = plateau[choixCouloir.x][i-1]
            fin pour
        fin si

    tuile_en_main = &tmp
FIN

-------------------
booléen validationCoup(Tuile *case,coordonnees a,coordonnees choix,entier compt) 
    // Tuile *case : adresse de la case précedente appelé dans l'appel précedent
    // coordonnees a : position de actuel de l'appel de la fonction
    // coordonnees choix : La case à atteindre
    // entier compt : nombre actuel des appels récursif de la fonction
DEBUT
    si(a.x == choix.x ET a.y == choix.y)
        retourne 1
    Fin si

    si(compt == 300) // Le plus long chemin possible pour être certain que la fonction parcours tous les chemins possible à partir de la coordonnees et  pour que ça s'arrête.
        retourne 0
    fin si

    si ((tab[a.x][a.y].d == 1 ET tab[a.x][a.y++].g == 1)  ET tab[a.x][a.y++] != case) // Si c'est "ouvert" à droite et si à droite c'est "ouvert" à 
                                                    //..gauche et que ce n'est pas la case précedente alors déplacer a (a.y incrémenté -> vers la droite)
        a.y++                                          // On déplace la coordonnees vers la "droite" ...
        res =validationCoup(tab[a.x][a.y--],a,choix,compt++) // Appel récursif 
    fin si

    si ((tab[a.x][a.y].h == 1 ET tab[a.x--][a.y].b == 1) ET tab[a.x--][a.y] != case) //...
        a.x--                                                                        //... 
        res= validationCoup(tab[a.x++][a.y],a,choix,compt++)                         //...
    fin si

    si ((tab[a.x][a.y].g == 1 ET tab[a.x][a.y--].d ==1) ET tab[a.x][a.y--] != case)
        a.y--
        res= validationCoup(tab[a.x][a.y++],a,choix,compt++)
    fin si

    si ((tab[a.x][a.y].b == 1 ET tab[a.x++][a.y].h == 1) ET tab[a.x++][a.y] != case)
        a.x++
        res= validationCoup(tab[a.x--][a.y],a,choix,compt++)
    fin si
    retourne res
FIN
-----------------------  
choixDeplacement(joueur *P1, Tuile plateau[7][7])
DEBUT
    booleen deplacement
    coordonnees choix

    Afficher (Entrer 1 pour déplacer, 0 pour rester à la case actuelle)
    Lire (deplacement)
    si deplacement = 0
        retourne 1
    fin si
    sinon
        Lire (choix.x)
        Lire (choix.y)
    Tant que(!validationCoup(plateau[P1->positionActuelle.x][P1->positionActuelle.y],P1->positionActuelle,choix,0))
        choixDeplacement(p1, plateau)
    fin Tant que

    retourne 1
FIN
------------------------
tresorAtteint(Joueur *P1, Tuile Plateau[7][7])
DEBUT
    coordonnees a = P1->positionActuelle
    si(plateau[a.x][a.y].tresor == P1->pileTresor)
        retourne 1
    fin si

    sinon
        retourne 0
FIN

        
